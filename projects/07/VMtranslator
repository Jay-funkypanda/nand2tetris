#!/usr/bin/env python3

from sys import argv
import os

# Messages
USAGE_MSG = "Usage: {0} <filename.vm>"
BAD_INPUT = "Invalid program. Terminating compilation"
BAD_FILE = "Problem reading from file or writing to file"

# Exit codes
CODE_SUCCESS = 0
CODE_FAILURE = -1

VM_EXTENSION = ".vm"
ASM_EXTENSION = ".asm"

# Stack Commands
C_ST_PUSH = "push"
C_ST_POP = "pop"

C_ST_ADD = "add"
C_ST_SUB = "sub"
C_ST_NEG = "neg"
C_ST_AND = "and"
C_ST_OR = "or"
C_ST_NOT = "not"
C_ST_LIST = [C_ST_ADD, C_ST_SUB, C_ST_NEG, C_ST_AND, C_ST_OR, C_ST_NOT]
OP_TO_SYMBOL = {C_ST_ADD : '+', C_ST_SUB : '-', C_ST_NEG : '-',
                C_ST_AND : "&", C_ST_OR : "|", C_ST_NOT : "!"}

# Stack comparison commands
C_ST_EQ = "eq"
C_ST_GT = "gt"
C_ST_LT = "lt"
C_ST_COMP_LIST = [C_ST_EQ, C_ST_GT, C_ST_LT]
OP_COMP_DICT = {C_ST_EQ : "JEQ", C_ST_GT : "JGT", C_ST_LT : "JLT"}

# Regular segments
SEG_ARG = "argument"
SEG_LCL = "local"
SEG_THIS = "this"
SEG_THAT = "that"
SEGMENTS = {SEG_ARG : "ARG", SEG_LCL : "LCL", SEG_THIS : "THIS", SEG_THAT : "THAT"}

C_PUSH_SEGMENT_TUP = tuple(["{0} {1}".format(C_ST_PUSH, segment) for segment in SEGMENTS]) # VM syntax: "push argument/local/etc."
C_POP_SEGMENT_TUP = tuple(["{0} {1}".format(C_ST_POP, segment) for segment in SEGMENTS]) # VM syntax: "pop argument/local/etc."

# Special segments
SEG_CONSTANT = "constant"
SEG_STATIC = "static"

C_PUSH_CONSTANT = "{0} {1}".format(C_ST_PUSH, SEG_CONSTANT) # VM syntax: "push constant"
C_POP_CONSTANT = "{0} {1}".format(C_ST_POP, SEG_CONSTANT) # VM syntax: "pop constant"
C_PUSH_STATIC_SEGMENT = "{0} {1}".format(C_ST_PUSH, SEG_STATIC) # VM syntax: "push static"
C_POP_STATIC_SEGMENT = "{0} {1}".format(C_ST_POP, SEG_STATIC)  # VM syntax: "pop static"

# Temporary segments
SEG_TMP = "temp"
SEG_POINTER = "pointer"
SEGMENTS_TMP = {SEG_POINTER : "3", SEG_TMP : "5"}

C_PUSH_TMP_SEGMENT_TUP = tuple(["{0} {1}".format(C_ST_PUSH, SEG_TMP),
                                "{0} {1}".format(C_ST_PUSH, SEG_POINTER)])
                                # VM syntax: "push temp", "push pointer"
                                
C_POP_TMP_SEGMENT_TUP = tuple(["{0} {1}".format(C_ST_POP, SEG_TMP),
                               "{0} {1}".format(C_ST_POP, SEG_POINTER)])
                                # VM syntax: "pop temp", "pop pointer"



# ASM code strings
PROG_INIT = """
@256
D=A
@SP
M=D
"""

OP_BINARY = """
@SP
M=M-1
A=M
D=M
@SP
M=M-1
A=M
M=M{0}D
@SP
M=M+1
"""

OP_UNARY = """
@SP
M=M-1
A=M
M={0}M
@SP
M=M+1
"""

OP_DICT = {C_ST_ADD : OP_BINARY.format(OP_TO_SYMBOL[C_ST_ADD]),
           C_ST_SUB : OP_BINARY.format(OP_TO_SYMBOL[C_ST_SUB]),
           C_ST_AND : OP_BINARY.format(OP_TO_SYMBOL[C_ST_AND]),
           C_ST_OR : OP_BINARY.format(OP_TO_SYMBOL[C_ST_OR]),
           C_ST_NEG : OP_UNARY.format(OP_TO_SYMBOL[C_ST_NEG]),
           C_ST_NOT : OP_UNARY.format(OP_TO_SYMBOL[C_ST_NOT]),
           }

OP_COMP = """
@SP
M=M-1
A=M
D=M
@SP
M=M-1
A=M

D=M-D
@TRUE{0}
D;{1}

(FALSE{0})
@SP
A=M
M=0
@CONT{0}
0;JMP

(TRUE{0})
@SP
A=M
M=-1

(CONT{0})
@SP
M=M+1
"""
             
OP_PUSH_CONST_HEADER = """
@{0}
D=A
"""

OP_PUSH_SEGMENT_HEADER = """
@{0}
D=A
@{1}
A=M+D
D=M
"""

OP_PUSH_SEGMENT_FOOTER = """
@SP
A=M
M=D
@SP
M=M+1
"""

OP_POP_SEGMENT_HEADER = """
@{0}
D=A
@{1}
D=M+D
@13
M=D
"""

OP_POP_SEGMENT_FOOTER = """
@SP
A=M-1
D=M
@SP
M=M-1
@R13
A=M
M=D
"""

OP_POP_CONST = """
@SP
M=M-1
"""

OP_PUSH_TMP_SEGMENT_HEADER = """
@{0}
D=A
@{1}
A=A+D
D=M
"""

OP_POP_TMP_SEGMENT_HEADER = """
@{0}
D=A
@{1}
D=A+D
@13
M=D
"""

OP_PUSH_STATIC_SEGMENT_HEADER = """
@{0}.{1}
D=M
"""

OP_POP_STATIC_SEGMENT = """
@SP
A=M-1
D=M
@SP
M=M-1
@{0}.{1}
M=D
"""

########

COMMENT_PREFIX = "//"

class Parser(object):
    """
    This class is built in order to perform the whole assembly process.
    Contains functions that handle the different textual aspects of the asm code,
    and converts them into the correct Hack bit codes.
    """
    
    def __init__(self):
        self.jump_counter = 0        

    def parse(self, filename, text):        
        """
        Main function of the parser.
        Receives raw text of a VM program, and returns its asm translation.
        """
        
        # Init program string
        result = PROG_INIT
        
        # Preliminary handling of input lines
        lines = text.splitlines()
        lines = self.clean_lines(lines)

        # Parse lines
        for line in lines:
            result += self.parse_line(line, filename)
        
        # Return the ready program code
        return result
    
       
    def clean_lines(self, lines):
        """
        Removes empty lines, comments and spaces.
        Returns a new list of lines, which are the actual program lines.
        """
        new_lines = []
        for line in lines:
            # Remove comments
            split_line = line.split(COMMENT_PREFIX)
            # Remove spaces
            clean_line = split_line[0].strip()
            if clean_line:
                # Add line only if it is an actual program line.
                new_lines.append(clean_line)
        return new_lines
                        
    def parse_line(self, line, filename):
        """
        Translates a single VM code line to an ASM code segment
        """        
        if line.startswith(C_PUSH_CONSTANT):
            # push constant x
            return OP_PUSH_CONST_HEADER.format(line.split()[-1]) + "\n" + OP_PUSH_SEGMENT_FOOTER

        elif line.startswith(C_POP_CONSTANT):
            # pop constant x (i.e just pop stack top)
            return OP_POP_CONST
        
        elif line in C_ST_LIST:
            # Arithmetic operation (add/sub/neg/not/and/or)
            return OP_DICT[line]
        
        elif line.startswith(C_PUSH_SEGMENT_TUP):
            # push <segment> <index> (argument/local/this/that)
            segment, index = SEGMENTS[line.split()[1]], line.split()[2]
            return OP_PUSH_SEGMENT_HEADER.format(index, segment) + "\n" + OP_PUSH_SEGMENT_FOOTER
        
        elif line.startswith(C_POP_SEGMENT_TUP):
            # pop <segment> <index> (argument/local/this/that)
            segment, index = SEGMENTS[line.split()[1]], line.split()[2]
            return OP_POP_SEGMENT_HEADER.format(index, segment) + "\n" + OP_POP_SEGMENT_FOOTER
        
        elif line.startswith(C_PUSH_TMP_SEGMENT_TUP):
            # push <tmp_segment> <index> (temp/pointer)
            segment, index = SEGMENTS_TMP[line.split()[1]], line.split()[2]
            return OP_PUSH_TMP_SEGMENT_HEADER.format(index, segment) + "\n" + OP_PUSH_SEGMENT_FOOTER
        
        elif line.startswith(C_POP_TMP_SEGMENT_TUP):
            # pop <tmp_segment> <index> (temp/pointer)
            segment, index = SEGMENTS_TMP[line.split()[1]], line.split()[2]
            return OP_POP_TMP_SEGMENT_HEADER.format(index, segment) + "\n" + OP_POP_SEGMENT_FOOTER

        elif line.startswith(C_PUSH_STATIC_SEGMENT):
            # push static x
            index = line.split()[2]
            return OP_PUSH_STATIC_SEGMENT_HEADER.format(filename, index) + "\n" + OP_PUSH_SEGMENT_FOOTER
        
        elif line.startswith(C_POP_STATIC_SEGMENT):
            # pop static x
            index = line.split()[2]
            return OP_POP_STATIC_SEGMENT.format(filename, index)

        elif line in C_ST_COMP_LIST:
            # Comparison (eq/gt/lt)
            self.jump_counter += 1
            return OP_COMP.format(self.jump_counter, OP_COMP_DICT[line])
                                            
def get_asm_filename(vm_filename):
    """
    Gets an input filename and returns the output Hack filename.
    """
    return "{0}.{1}".format(os.path.splitext(vm_filename)[0], ASM_EXTENSION)

def main(path):
	if os.path.isdir(path):
		for filename in os.listdir(path):
			if filename.endswith(VM_EXTENSION):
				handle_file(path + "/" + filename)
	else:
		handle_file(path)
    
def handle_file(vm_filename):
    """
    Main program - compiles the given file,
    and saves the output to a Hack file.
    """
    
    parser = Parser()
    
    # Open input file and handle file errors
    try:
        text = open(vm_filename).read()
    except OSError:
        raise
    
    # Compile file content and handle compilation errors
    try:
        asm_program = parser.parse(os.path.basename(vm_filename).split('.')[0], text)        
    except:
        raise Exception(BAD_INPUT)        
    
    # Write to Hack file and handle file errors.
    asm_filename = get_asm_filename(vm_filename)
    try:
        open(asm_filename, 'w').write(asm_program)
    except OSError:
        raise
            
def usage():
    """
    Prints a usage message to the user.
    """
    print(USAGE_MSG.format(argv[0]))

if __name__=="__main__":

    if len(argv) != 2:
        # Invalid command line arguments
        usage()
        exit(CODE_SUCCESS)
        
    # Run program, exit(-1) on failure
    try:
        main(argv[1])
    except OSError as e:
        print(BAD_FILE)
        exit(CODE_FAILURE)
    except Exception as e:
        raise
        exit(CODE_FAILURE)
    
    # exit(0) on success
    exit(CODE_SUCCESS)
    
    
    
